<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Semantic Morphing Table</title>

    <link href="https://fonts.googleapis.com/css?family=Aldrich" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.grey-indigo.min.css" />

    <style>

        body {
            font-family: 'Aldrich', sans-serif;
            margin: 0;
        }

        canvas { width: 100%; height: 100% }

        h1 {
            font-size: 20px;
            line-height: 20px;
            margin: 0;
        }

        .floating {

            position: absolute;
            padding: 30px;
            width: 600px;

        }

        .navigator {
            padding-top: 20px;
        }

        .navigator .create {
            text-align: right;
        }

    </style>

</head>
<body>
    <div id="Stats-output">

    <div class="floating" id="app">
        <h1>SEMANTIC MORPHING</h1>

        <section class="navigator">
    
            <table class="mdl-data-table mdl-js-data-table mdl-shadow--2dp">
                <tbody>
                    <tr>
                        <td>TABLE 1</td>
                        <td><input id="table1" class="mdl-slider mdl-js-slider" type="range" min="0" :max="number_of_tables - 1" v-model="table_index_1" tabindex="0"></td>
                        <td>[[ table_index_1 ]]</td>
                    </tr>
                    <tr>
                        <td>TABLE 2</td>
                        <td><input id="table2" class="mdl-slider mdl-js-slider" type="range" min="0" :max="number_of_tables - 1" v-model="table_index_2" tabindex="1"></td>
                        <td>[[ table_index_2 ]]</td>
                    </tr>
                    {% if not True %}
                    <tr>
                        <td>ALPHA</td>
                        <td><input id="alpha" class="mdl-slider mdl-js-slider" type="range" min="0" max="1" v-model="alpha" step="0.1" tabindex="2"></td>
                        <td>[[ alpha ]]</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td><button class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect create" v-on:click="create">CREATE</button></td>
                    </tr>
                    {% endif %}
                </tbody>
            </table>
                        
        </section>
    </div>

</body>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.min.js"></script>
<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>

<script type="module">

import {PointCloud} from "/static/js/lib/pointcloud.js"
import {fetchPointClouds} from "/static/js/lib/api.js"

(function() {

    const numberOfTables = 20

    var app = new Vue({
        el: '#app',
        data: {
            table_index_1: 0,
            table_index_2: 9,
            alpha: 0.5,
            number_of_tables: numberOfTables,
            input_data: [],
            input_point_cloud_1: null,
            input_point_cloud_2: null,
            merged_point_clouds: []
        },
        watch: {

            table_index_1: function (newValue, oldValue) {

                if (app.input_point_cloud_1) {

                    app.input_point_cloud_1.update(this.input_data[newValue])
                    this.create(null)
                }

            },
            table_index_2: function (newValue, oldValue) {

                if (app.input_point_cloud_2) {

                    app.input_point_cloud_2.update(this.input_data[newValue])
                    this.create(null)
                }

            },
            alpha: function (newValue, oldValue) {
                this.create(null)
            }
        },
        methods: {
            create: function (event) {
                

                const array1 = this.input_data[this.table_index_1]
                const array2 = this.input_data[this.table_index_2]

                let x1List = []
                let y1List = []
                let z1List = []
                let x2List = []
                let y2List = []
                let z2List = []

                for (let i = 0; i < array1.length; i++) {

                    const coordinate1 = array1[i]
                    const coordinate2 = array2[i]

                    const x1  = coordinate1[0]
                    const y1  = coordinate1[1]
                    const z1  = coordinate1[2]

                    const x2  = coordinate1[0]
                    const y2  = coordinate2[1]
                    const z2  = coordinate2[2]

                    x1List.push(x1)
                    y1List.push(y1)
                    z1List.push(z1)
                    x2List.push(x2)
                    y2List.push(y2)
                    z2List.push(z2)
                }

                axios.post('/manipulate', {
                    x1: x1List,
                    y1: y1List,
                    z1: z1List,
                    x2: x2List,
                    y2: y2List,
                    z2: z2List,
                    alpha: this.alpha
                })
                .then(function (response) {

                    if (app.merged_point_clouds.length > 0) {

                        for (let i = 0; i < response.data.point_clouds.length; i++) {

                            const pc = app.merged_point_clouds[i]
                            pc.update(response.data.point_clouds[i])
                            //pc.resetRotation()
                        }

                    } else {

                        for (let i = 0; i < response.data.point_clouds.length; i++) {

                            const pc = new PointCloud(response.data.point_clouds[i])
                            pc.point.name = i
                            app.merged_point_clouds.push(pc)
                            pc.add(scene)
                            pc.move(-25 + 10 * i, -10, 0)
                        }
                    }

                    //app.input_point_cloud_1.resetRotation()
                    //app.input_point_cloud_2.resetRotation()

                })
                .catch(function (error) {
                    // handle error
                    console.log(error)
                })
                .then(function () {
                    // always executed
                })    
            
            }
        },
        delimiters: ['[[',']]']
    })

    
    fetchPointClouds(numberOfTables, function(response) {

        app.input_data = response.data.point_clouds

        const pc1 = new PointCloud(app.input_data[app.table_index_1])
        pc1.move(-24, 5, 0)
        pc1.add(scene)
        app.input_point_cloud_1 = pc1

        const pc2 = new PointCloud(app.input_data[app.table_index_2])
        pc2.move(24, 5, 0)
        pc2.add(scene)
        app.input_point_cloud_2 = pc2

        app.create(null)

    }, function(error) {

    })

    const scene  = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)

    const renderer = new THREE.WebGLRenderer()
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement)

    scene.background = new THREE.Color( 0xffffff );
    camera.position.z = 30

    const raycaster = new THREE.Raycaster()

    const stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    stats.domElement.style.right = '0px';
    stats.domElement.style.zIndex = 100;
    document.body.appendChild(stats.domElement)

    let rotate = 0.015
    var animate = function () {

        requestAnimationFrame(animate)

        stats.update()

        if (app.input_point_cloud_1) {

            app.input_point_cloud_1.rotate(-0.012, 0.007, 0.001)
        }

        if (app.input_point_cloud_2) {

            app.input_point_cloud_2.rotate(-0.012, 0.007, 0.001)
        }

        app.merged_point_clouds.forEach(function(pc) {

            pc.rotate(-0.012, 0.007, 0.001)
        })

        renderer.render(scene, camera)
    }

    animate()

    window.addEventListener('mousedown', onDocumentMouseDown, false)
    function onDocumentMouseDown(event) {

        //event.preventDefault()

        if (app.merged_point_clouds.length == 0) { return }

        let rayReceiveObjects = []

        app.merged_point_clouds.forEach(function(pc) {

            rayReceiveObjects.push(pc.point)
        })

        let mouse = new THREE.Vector2()

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

        raycaster.setFromCamera( mouse, camera )
        const intersects = raycaster.intersectObjects( rayReceiveObjects )

        if (intersects.length > 0) {

            const id = intersects[0].object.name

            const pc = app.merged_point_clouds[id]

            if (pc.meshVisible) {

                pc.switch()
                return
            }

            const array = pc.point_cloud

            let xList = []
            let yList = []
            let zList = []

            for (let i = 0; i < array.length; i++) {

                const coordinate = array[i]

                const x  = coordinate[0]
                const y  = coordinate[1]
                const z  = coordinate[2]

                xList.push(x)
                yList.push(y)
                zList.push(z)
            }

            axios.post('/generate_mesh', {
                x: xList,
                y: yList,
                z: zList,
            })
            .then(function (response) {

                let array = response.data.split('\n')
                array = array.slice(2, array.length - 1)

                app.merged_point_clouds[id].mesh(array)

            })


        }
    }


})()
</script>

</html>
